<?php

/**
 * Basiin Transaction object
 *
 * NOTE: after FEB 12 2012, all transactions and transfers get generated numeric 
 *       ids from the DB (data/basin.db).
 *       
 * after initiating a transfer through:
 *  Basiin/init/transfer/$transactionId/$DataLength/$maxPieceLength
 * to which basiin returns:
 *  js:$transactionId.loader.setuptransfer( transferTag, length, pieces )
 * 
 * /NOTE
 *
 *
 * one of theese is created inside the user's session (persistent local store)
 * for each transaction that is started
 *
 * @property BTransfer[] $transfers
 * @property string $id
 * @property boolean $keepAlive when true Basiin js is set up to call home and
 *                              keep the transaction alive
 * @property integer $started timestamp of the time the BT was initiated
 * @property integer $ttl time to live of transaction basiin::TransactionTimeOutSec
 * @property integer $maxTransfers how many transfers can be initiated?
 * @property integer $maxElements how many elements can be actively transfering?
 *
 * @method string getDefaultPath return a valid url to wich basiin can send data
 * 
 * @author Kiriakos
 */
class BTransaction extends EBasiinActiveRecord {
    
    /**
     *  Hash generated by Basiin::generateTransactionId()
     * @var string
     */
    protected $id;
    /**
     *  Timestamp of the epoch second the transaction was created
     * @var integer
     */
    protected $started;
    /**
     *  Timestamp of the epoch second the transaction will time out
     * @var integer
     */
    protected $timeout;


    /* BASIIN properties populated on __construct */
    
    /**
     *  Lifespan of idle transactions (in seconds) time to live
     * 
     * alias to Basiin::TransactionTTL
     
     * @var integer
     */
    protected $ttl;

    /**
     *  The quantity of concurent transfers, see Basiin::MaxConcursiveTransfers
     * @var integer
     */
    protected $maxTransfers;

    /**
     *  The quantity of concurently existing html elements, see Basiin::MaxConcursiveElements
     * @var integer
     */
    protected $maxElements;

    
    protected $models = array(
        'transfers'=> array(
            'model'=> 'BTransfers',
            'container'=>"array"
            )
    );

    /**
     *  TODO: what use is this?
     * @var boolean
     */
    protected $keepAlive = False;
        public function setKeepAlive($b){return ($this->keepAlive = (bool)$b);}
        public function getKeepAlive(){return $this->keepAlive;}

    
    
    public function __construct($id = NULL, $data = NULL) {

        $this->_setup();

        if($id===NULL) $id = Basiin::generateTransactionId();
        $this->id = $id;
        if ($data !== NULL)
            $this->unpack($data);
        else
            $this->_initialize();



        
    }
    
    /**
     * Populate the Basiin speciffic parameters
     */
    private function _setup(){
        $this->ttl = Basiin::TransactionTimeOutSec;
        $this->maxTransfers = Basiin::MaxConcursiveTransfers;
        $this->maxElements = Basiin::MaxConcursiveElements;
    }

    /**
     * Called when a new instance is created without packed $data
     */
    private function _initialize(){
        $this->started = time();
        $this->timeout = time() + $this->ttl;
    }

    /**
     * The path to which to send data to
     * @return string
     */
    public function getDefaultPath(){
        return 'basiin/tell/'.$this->id;
    }
    

    /**
     *  Unpacks BTransfer objects in $transfers and returns the resulting array
     * @param packedBTransfer[] $transfers
     * @return BTransfer[]
     */
    private function unpackTransfers($transfers){
        $result = array();
        foreach ($transfers as $tag=>$transfer){
            $result[$tag]= new BTransfer($tag,$transfer);
        }
        return $result;
    }

    /**
     *  Returns the transfer with the correct $tag or False
     * @param string $tag
     * @return BTransfer false
     */
    public function getTransfer($tag){
        foreach ($this->transfers as $transfer)
                if ($transfer->tag == $tag) return $transfer;

        return false;
    }

    /**
     * Creates a BTransfer with $tag ($data) and appends it to the transaction
     * @param string $tag
     * @param string $data
     * @return BTransfer
     */
    public function newTransfer($tag){
        
        $transfer = new BTransfer($tag);
        
        $this->transfers[] =$transfer;

        return $transfer;
    }
}
?>
